config {
  type: "table",
  schema: dataform.projectConfig.vars.schema,
  tags: ["ga4","intermediate","pageviews"],
  bigquery: {
    partitionBy: "DATE(event_ts)",
    clusterBy: ["user_pseudo_id","ga_session_id"]
  }
}

/* Use ONLY columns that exist in raw_page_source */
WITH base AS (
  SELECT
    user_pseudo_id,
    ga_session_id,
    event_ts,
    event_date,
    page_url,
    page_title,
    author_name,            -- may be NULL on non-article events
    scroll_pct,             -- INT, only present on scroll events
    time_spent_sec,         -- INT, only present on time_on_page events
    event_name
  FROM ${ref("raw_page_source")}
),

/* Keep only real page views (ordering anchor for RN/LEAD) */
pv AS (
  SELECT *
  FROM base
  WHERE event_name = 'page_view'
),

/* Aggregate per (session_id, page_url) */
scroll AS (
  SELECT
    CONCAT(user_pseudo_id, "-", CAST(ga_session_id AS STRING)) AS session_id,
    page_url,
    MAX(scroll_pct) AS max_scroll_percentage
  FROM base
  WHERE scroll_pct IS NOT NULL
  GROUP BY 1,2
),
time_on_page AS (
  SELECT
    CONCAT(user_pseudo_id, "-", CAST(ga_session_id AS STRING)) AS session_id,
    page_url,
    MAX(time_spent_sec) AS max_time_on_page
  FROM base
  WHERE time_spent_sec IS NOT NULL
  GROUP BY 1,2
),

/* One author per (session,page). If you only store author at article_view rows,
   this will still safely return NULL when absent. */
authors AS (
  SELECT
    CONCAT(user_pseudo_id, "-", CAST(ga_session_id AS STRING)) AS session_id,
    page_url,
    ANY_VALUE(author_name IGNORE NULLS) AS author_name
  FROM base
  WHERE author_name IS NOT NULL
  GROUP BY 1,2
)

SELECT
  DATE(pv.event_ts) AS session_date,
  pv.user_pseudo_id,
  CONCAT(pv.user_pseudo_id, "-", CAST(pv.ga_session_id AS STRING)) AS session_id,
  pv.page_url,
  pv.page_title,

  /* theme/page categories parsed from URL path (robust defaults) */
  COALESCE(
    NULLIF(SPLIT(REGEXP_EXTRACT(pv.page_url, r'^https?://[^/]+/([^?#]*)'), '/')[SAFE_OFFSET(0)], ''),
    'hotspawn'
  ) AS theme_category,
  COALESCE(
    NULLIF(SPLIT(REGEXP_EXTRACT(pv.page_url, r'^https?://[^/]+/([^?#]*)'), '/')[SAFE_OFFSET(1)], ''),
    'hotspawn'
  ) AS page_category,

  COALESCE(a.author_name, 'hotspawn')                               AS author_name,
  COALESCE(s.max_scroll_percentage, 10)                             AS max_scroll_percentage,
  COALESCE(t.max_time_on_page, 15)                                  AS max_time_on_page,

  ROW_NUMBER() OVER (PARTITION BY pv.user_pseudo_id, pv.ga_session_id ORDER BY pv.event_ts) AS pageview_number,
  LEAD(pv.page_url) OVER (PARTITION BY pv.user_pseudo_id, pv.ga_session_id ORDER BY pv.event_ts) AS next_page_url,

  /* User type from the users model */
  u.user_type,

  CASE WHEN ROW_NUMBER() OVER (PARTITION BY pv.user_pseudo_id, pv.ga_session_id ORDER BY pv.event_ts) = 1 THEN 1 ELSE 0 END AS isLandingPage,
  CASE WHEN ROW_NUMBER() OVER (PARTITION BY pv.user_pseudo_id, pv.ga_session_id ORDER BY pv.event_ts DESC) = 1 THEN 1 ELSE 0 END AS isExitPage,

  LAST_VALUE(pv.page_url) OVER (
    PARTITION BY pv.user_pseudo_id, pv.ga_session_id
    ORDER BY pv.event_ts
    ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
  ) AS exit_page_url

FROM pv
LEFT JOIN scroll        s ON s.session_id = CONCAT(pv.user_pseudo_id, "-", CAST(pv.ga_session_id AS STRING))
                         AND s.page_url   = pv.page_url
LEFT JOIN time_on_page  t ON t.session_id = CONCAT(pv.user_pseudo_id, "-", CAST(pv.ga_session_id AS STRING))
                         AND t.page_url   = pv.page_url
LEFT JOIN ${ref("int_users")} u USING (user_pseudo_id)
